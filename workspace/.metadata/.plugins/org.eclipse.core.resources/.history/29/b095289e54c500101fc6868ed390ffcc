#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "includes.h"
#include "simple_socket_server.h"
#include "alt_error_handler.h"
#include "ipport.h"
#include "tcpport.h"
#include "libport.h"
#include "osport.h"
#include <io.h>


#define MAX_CHARS 1000

// Endereços dos registradores User_HW
#define ADDR_CONTROL 0
#define ADDR_DATA    1
#define ADDR_READY   2
#define ADDR_OUTPUT  3

OS_STK    SSSInitialTaskStk[TASK_STACKSIZE];

// ======================================================
// PROCESSAMENTO NO HARDWARE (mantive sua função)
unsigned char process_byte(unsigned char byte) {
    IOWR(USERHW_0_BASE, ADDR_DATA, byte);     // envia byte
    IOWR(USERHW_0_BASE, ADDR_CONTROL, 1);     // start

    while (IORD(USERHW_0_BASE, ADDR_READY) == 0)
        ; // espera

    unsigned int ans = IORD(USERHW_0_BASE, ADDR_OUTPUT); // recebe

    IOWR(USERHW_0_BASE, ADDR_CONTROL, 0); // limpa start

    return (unsigned char)(ans & 0xFF);
}

void process_string(unsigned char* input, unsigned char* output, int length) {
    if (length <= 0) return;
    if (length > MAX_CHARS) length = MAX_CHARS;
    for (int i = 0; i < length; i++)
        output[i] = process_byte(input[i]);
}

// ======================================================
// SERVIDOR TCP – porta 9090 (corrigi print)
void tcp_server(void *p) {
    int sock, client;
    struct sockaddr_in addr, cli;
    char recv_buffer[MAX_CHARS + 1];
    char send_buffer[MAX_CHARS + 1];
    int bytes;

    // inicialização do TCP/IP stack
    alt_iniche_init();
    netmain();

    // aguarda DHCP pegar IP
    while (iniche_net_ready == 0) {
        TK_SLEEP(10);
    }

    printf("Rede pronta. IP obtido via DHCP.\n");

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        printf("Erro criando socket\n");
        return;
    }

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9090);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        printf("bind() falhou\n");
        close(sock);
        return;
    }

    listen(sock, 1);
    printf("Servidor TCP pronto na porta 9090\n");

    // aceita um cliente (mantive sem loop conforme seu código)
    int cli_len = sizeof(cli);
    client = accept(sock, (struct sockaddr *)&cli, &cli_len);

    if (client < 0) {
        printf("Erro no accept\n");
        close(sock);
        return;
    }

    printf("Cliente conectado.\n");

    memset(recv_buffer, 0, sizeof(recv_buffer));
    memset(send_buffer, 0, sizeof(send_buffer));

    bytes = recv(client, recv_buffer, sizeof(recv_buffer) - 1, 0);
    if (bytes <= 0) {
        printf("Cliente desconectou antes de enviar ou recv erro (%d).\n", bytes);
        close(client);
        close(sock);
        return;
    }
    // garante terminação
    recv_buffer[bytes] = '\0';

    // procura o início do body: cabeçalho HTTP termina em "\r\n\r\n"
    char *body = strstr(recv_buffer, "\r\n\r\n");
    if (!body) {
        // header não encontrado — lidar de forma segura
        printf("Separador de headers não encontrado. Recebido: %d bytes\n", bytes);
        close(client);
        close(sock);
        return;
    }

    // body aponta para após "\r\n\r\n"
    body += 4;

    // se você espera por um prefixo fixo no body (por ex. "payload: "), trate com segurança:
    // body += 9;  // <- NÃO faça sem checar: subi isso apenas se tiver certeza
    // Se realmente precisa pular 9 bytes, verifique o comprimento antes:
    if ((size_t)(body - recv_buffer) + 9 <= (size_t)bytes) {
        body += 9;
    } else {
        // não há 9 bytes disponíveis após o header
        printf("Body muito curto para pular 9 bytes.\n");
        close(client);
        close(sock);
        return;
    }

    // cálculo seguro do tamanho do body disponível
    int body_len = bytes - (int)(body - recv_buffer);
    if (body_len < 0) body_len = 0;
    if (body_len > MAX_CHARS) body_len = MAX_CHARS;

    // Processamento no User_HW — converte para unsigned char
    process_string((unsigned char*)body, (unsigned char*)send_buffer, body_len);

    // envia resposta (use o tamanho processado)
    int sent = send(client, send_buffer, body_len, 0);
    if (sent < 0) {
        printf("Erro ao enviar resposta\n");
    } else {
        printf("Enviado de volta: %d bytes\n", sent);
    }

    close(client);
    close(sock);
}

// ======================================================
// MAIN – cria a thread do servidor TCP
int main() {
    INT8U error_code;
    OSTimeSet(0);
    printf("Inicializando sistema...\n");

    // CRITICAL: corrija o ponteiro de stack passado (não use [TASK_STACKSIZE], use [TASK_STACKSIZE-1])
    error_code = OSTaskCreateExt(tcp_server,
                               NULL,
                               (void *)&SSSInitialTaskStk[TASK_STACKSIZE - 1], // CORREÇÃO
                               SSS_INITIAL_TASK_PRIORITY,
                               SSS_INITIAL_TASK_PRIORITY,
                               SSSInitialTaskStk,
                               TASK_STACKSIZE,
                               NULL,
                               0);
    alt_uCOSIIErrorHandler(error_code, 0);
    printf("Servidor TCP criado.\n");

    OSStart(); // inicia o MicroC/OS-II
    while (1);
    return 0;
}
