-- q_sys_ext_epcq_flash.vhd

-- This file was auto-generated from altera_epcq_controller2_hw.tcl.  If you edit it your changes
-- will probably be lost.
-- 
-- Generated using ACDS version 17.1 590

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity q_sys_ext_epcq_flash is
	generic (
		DEVICE_FAMILY     : string  := "Cyclone 10 LP";
		ASI_WIDTH         : integer := 1;
		CS_WIDTH          : integer := 1;
		ADDR_WIDTH        : integer := 21;
		ASMI_ADDR_WIDTH   : integer := 24;
		ENABLE_4BYTE_ADDR : integer := 0;
		CHIP_SELS         : integer := 1
	);
	port (
		avl_csr_read         : in  std_logic                     := '0';             --          avl_csr.read
		avl_csr_waitrequest  : out std_logic;                                        --                 .waitrequest
		avl_csr_write        : in  std_logic                     := '0';             --                 .write
		avl_csr_addr         : in  std_logic_vector(3 downto 0)  := (others => '0'); --                 .address
		avl_csr_wrdata       : in  std_logic_vector(31 downto 0) := (others => '0'); --                 .writedata
		avl_csr_rddata       : out std_logic_vector(31 downto 0);                    --                 .readdata
		avl_csr_rddata_valid : out std_logic;                                        --                 .readdatavalid
		avl_mem_write        : in  std_logic                     := '0';             --          avl_mem.write
		avl_mem_burstcount   : in  std_logic_vector(6 downto 0)  := (others => '0'); --                 .burstcount
		avl_mem_waitrequest  : out std_logic;                                        --                 .waitrequest
		avl_mem_read         : in  std_logic                     := '0';             --                 .read
		avl_mem_addr         : in  std_logic_vector(20 downto 0) := (others => '0'); --                 .address
		avl_mem_wrdata       : in  std_logic_vector(31 downto 0) := (others => '0'); --                 .writedata
		avl_mem_rddata       : out std_logic_vector(31 downto 0);                    --                 .readdata
		avl_mem_rddata_valid : out std_logic;                                        --                 .readdatavalid
		avl_mem_byteenable   : in  std_logic_vector(3 downto 0)  := (others => '0'); --                 .byteenable
		irq                  : out std_logic;                                        -- interrupt_sender.irq
		clk                  : in  std_logic                     := '0';             --       clock_sink.clk
		reset_n              : in  std_logic                     := '0'              --            reset.reset_n
	);
end entity q_sys_ext_epcq_flash;

architecture rtl of q_sys_ext_epcq_flash is
	component q_sys_ext_epcq_flash_asmi2_inst_epcq_ctrl is
		port (
			avl_csr_address         : in  std_logic_vector(5 downto 0)  := (others => 'X'); -- address
			avl_csr_read            : in  std_logic                     := 'X';             -- read
			avl_csr_readdata        : out std_logic_vector(31 downto 0);                    -- readdata
			avl_csr_write           : in  std_logic                     := 'X';             -- write
			avl_csr_writedata       : in  std_logic_vector(31 downto 0) := (others => 'X'); -- writedata
			avl_csr_waitrequest     : out std_logic;                                        -- waitrequest
			avl_csr_readdatavalid   : out std_logic;                                        -- readdatavalid
			avl_mem_address         : in  std_logic_vector(31 downto 0) := (others => 'X'); -- address
			avl_mem_read            : in  std_logic                     := 'X';             -- read
			avl_mem_readdata        : out std_logic_vector(31 downto 0);                    -- readdata
			avl_mem_write           : in  std_logic                     := 'X';             -- write
			avl_mem_writedata       : in  std_logic_vector(31 downto 0) := (others => 'X'); -- writedata
			avl_mem_byteenable      : in  std_logic_vector(3 downto 0)  := (others => 'X'); -- byteenable
			avl_mem_burstcount      : in  std_logic_vector(6 downto 0)  := (others => 'X'); -- burstcount
			avl_mem_waitrequest     : out std_logic;                                        -- waitrequest
			avl_mem_readdatavalid   : out std_logic;                                        -- readdatavalid
			clk_clk                 : in  std_logic                     := 'X';             -- clk
			reset_reset             : in  std_logic                     := 'X';             -- reset
			chip_select_chip_select : in  std_logic_vector(3 downto 0)  := (others => 'X')  -- chip_select
		);
	end component q_sys_ext_epcq_flash_asmi2_inst_epcq_ctrl;

	component q_sys_ext_epcq_flash_addr_adaption_0 is
		port (
			clk                   : in  std_logic                     := 'X';             -- clk
			reset                 : in  std_logic                     := 'X';             -- reset
			avl_csr_read          : in  std_logic                     := 'X';             -- read
			avl_csr_waitrequest   : out std_logic;                                        -- waitrequest
			avl_csr_write         : in  std_logic                     := 'X';             -- write
			avl_csr_addr          : in  std_logic_vector(3 downto 0)  := (others => 'X'); -- address
			avl_csr_wrdata        : in  std_logic_vector(31 downto 0) := (others => 'X'); -- writedata
			avl_csr_rddata        : out std_logic_vector(31 downto 0);                    -- readdata
			avl_csr_rddata_valid  : out std_logic;                                        -- readdatavalid
			asmi_csr_addr         : out std_logic_vector(5 downto 0);                     -- address
			asmi_csr_read         : out std_logic;                                        -- read
			asmi_csr_rddata       : in  std_logic_vector(31 downto 0) := (others => 'X'); -- readdata
			asmi_csr_write        : out std_logic;                                        -- write
			asmi_csr_wrdata       : out std_logic_vector(31 downto 0);                    -- writedata
			asmi_csr_waitrequest  : in  std_logic                     := 'X';             -- waitrequest
			asmi_csr_rddata_valid : in  std_logic                     := 'X';             -- readdatavalid
			avl_mem_write         : in  std_logic                     := 'X';             -- write
			avl_mem_burstcount    : in  std_logic_vector(6 downto 0)  := (others => 'X'); -- burstcount
			avl_mem_waitrequest   : out std_logic;                                        -- waitrequest
			avl_mem_read          : in  std_logic                     := 'X';             -- read
			avl_mem_addr          : in  std_logic_vector(20 downto 0) := (others => 'X'); -- address
			avl_mem_wrdata        : in  std_logic_vector(31 downto 0) := (others => 'X'); -- writedata
			avl_mem_rddata        : out std_logic_vector(31 downto 0);                    -- readdata
			avl_mem_rddata_valid  : out std_logic;                                        -- readdatavalid
			avl_mem_byteenable    : in  std_logic_vector(3 downto 0)  := (others => 'X'); -- byteenable
			asmi_mem_addr         : out std_logic_vector(31 downto 0);                    -- address
			asmi_mem_read         : out std_logic;                                        -- read
			asmi_mem_rddata       : in  std_logic_vector(31 downto 0) := (others => 'X'); -- readdata
			asmi_mem_write        : out std_logic;                                        -- write
			asmi_mem_wrdata       : out std_logic_vector(31 downto 0);                    -- writedata
			asmi_mem_byteenable   : out std_logic_vector(3 downto 0);                     -- byteenable
			asmi_mem_burstcount   : out std_logic_vector(6 downto 0);                     -- burstcount
			asmi_mem_waitrequest  : in  std_logic                     := 'X';             -- waitrequest
			asmi_mem_rddata_valid : in  std_logic                     := 'X';             -- readdatavalid
			irq                   : out std_logic;                                        -- irq
			chip_select           : out std_logic_vector(3 downto 0)                      -- chip_select
		);
	end component q_sys_ext_epcq_flash_addr_adaption_0;

	signal addr_adaption_0_asmi_mem_readdata       : std_logic_vector(31 downto 0); -- asmi2_inst_epcq_ctrl:avl_mem_readdata -> addr_adaption_0:asmi_mem_rddata
	signal addr_adaption_0_asmi_mem_waitrequest    : std_logic;                     -- asmi2_inst_epcq_ctrl:avl_mem_waitrequest -> addr_adaption_0:asmi_mem_waitrequest
	signal addr_adaption_0_asmi_mem_address        : std_logic_vector(31 downto 0); -- addr_adaption_0:asmi_mem_addr -> asmi2_inst_epcq_ctrl:avl_mem_address
	signal addr_adaption_0_asmi_mem_read           : std_logic;                     -- addr_adaption_0:asmi_mem_read -> asmi2_inst_epcq_ctrl:avl_mem_read
	signal addr_adaption_0_asmi_mem_byteenable     : std_logic_vector(3 downto 0);  -- addr_adaption_0:asmi_mem_byteenable -> asmi2_inst_epcq_ctrl:avl_mem_byteenable
	signal addr_adaption_0_asmi_mem_readdatavalid  : std_logic;                     -- asmi2_inst_epcq_ctrl:avl_mem_readdatavalid -> addr_adaption_0:asmi_mem_rddata_valid
	signal addr_adaption_0_asmi_mem_write          : std_logic;                     -- addr_adaption_0:asmi_mem_write -> asmi2_inst_epcq_ctrl:avl_mem_write
	signal addr_adaption_0_asmi_mem_writedata      : std_logic_vector(31 downto 0); -- addr_adaption_0:asmi_mem_wrdata -> asmi2_inst_epcq_ctrl:avl_mem_writedata
	signal addr_adaption_0_asmi_mem_burstcount     : std_logic_vector(6 downto 0);  -- addr_adaption_0:asmi_mem_burstcount -> asmi2_inst_epcq_ctrl:avl_mem_burstcount
	signal addr_adaption_0_asmi_csr_readdata       : std_logic_vector(31 downto 0); -- asmi2_inst_epcq_ctrl:avl_csr_readdata -> addr_adaption_0:asmi_csr_rddata
	signal addr_adaption_0_asmi_csr_waitrequest    : std_logic;                     -- asmi2_inst_epcq_ctrl:avl_csr_waitrequest -> addr_adaption_0:asmi_csr_waitrequest
	signal addr_adaption_0_asmi_csr_address        : std_logic_vector(5 downto 0);  -- addr_adaption_0:asmi_csr_addr -> asmi2_inst_epcq_ctrl:avl_csr_address
	signal addr_adaption_0_asmi_csr_read           : std_logic;                     -- addr_adaption_0:asmi_csr_read -> asmi2_inst_epcq_ctrl:avl_csr_read
	signal addr_adaption_0_asmi_csr_readdatavalid  : std_logic;                     -- asmi2_inst_epcq_ctrl:avl_csr_readdatavalid -> addr_adaption_0:asmi_csr_rddata_valid
	signal addr_adaption_0_asmi_csr_write          : std_logic;                     -- addr_adaption_0:asmi_csr_write -> asmi2_inst_epcq_ctrl:avl_csr_write
	signal addr_adaption_0_asmi_csr_writedata      : std_logic_vector(31 downto 0); -- addr_adaption_0:asmi_csr_wrdata -> asmi2_inst_epcq_ctrl:avl_csr_writedata
	signal addr_adaption_0_chip_select_chip_select : std_logic_vector(3 downto 0);  -- addr_adaption_0:chip_select -> asmi2_inst_epcq_ctrl:chip_select_chip_select
	signal reset_n_ports_inv                       : std_logic;                     -- reset_n:inv -> [addr_adaption_0:reset, asmi2_inst_epcq_ctrl:reset_reset]

begin

	device_family_check : if DEVICE_FAMILY /= "Cyclone 10 LP" generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	asi_width_check : if ASI_WIDTH /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	cs_width_check : if CS_WIDTH /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	addr_width_check : if ADDR_WIDTH /= 21 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	asmi_addr_width_check : if ASMI_ADDR_WIDTH /= 24 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	enable_4byte_addr_check : if ENABLE_4BYTE_ADDR /= 0 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	chip_sels_check : if CHIP_SELS /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	asmi2_inst_epcq_ctrl : component q_sys_ext_epcq_flash_asmi2_inst_epcq_ctrl
		port map (
			avl_csr_address         => addr_adaption_0_asmi_csr_address,        --     avl_csr.address
			avl_csr_read            => addr_adaption_0_asmi_csr_read,           --            .read
			avl_csr_readdata        => addr_adaption_0_asmi_csr_readdata,       --            .readdata
			avl_csr_write           => addr_adaption_0_asmi_csr_write,          --            .write
			avl_csr_writedata       => addr_adaption_0_asmi_csr_writedata,      --            .writedata
			avl_csr_waitrequest     => addr_adaption_0_asmi_csr_waitrequest,    --            .waitrequest
			avl_csr_readdatavalid   => addr_adaption_0_asmi_csr_readdatavalid,  --            .readdatavalid
			avl_mem_address         => addr_adaption_0_asmi_mem_address,        --     avl_mem.address
			avl_mem_read            => addr_adaption_0_asmi_mem_read,           --            .read
			avl_mem_readdata        => addr_adaption_0_asmi_mem_readdata,       --            .readdata
			avl_mem_write           => addr_adaption_0_asmi_mem_write,          --            .write
			avl_mem_writedata       => addr_adaption_0_asmi_mem_writedata,      --            .writedata
			avl_mem_byteenable      => addr_adaption_0_asmi_mem_byteenable,     --            .byteenable
			avl_mem_burstcount      => addr_adaption_0_asmi_mem_burstcount,     --            .burstcount
			avl_mem_waitrequest     => addr_adaption_0_asmi_mem_waitrequest,    --            .waitrequest
			avl_mem_readdatavalid   => addr_adaption_0_asmi_mem_readdatavalid,  --            .readdatavalid
			clk_clk                 => clk,                                     --         clk.clk
			reset_reset             => reset_n_ports_inv,                       --       reset.reset
			chip_select_chip_select => addr_adaption_0_chip_select_chip_select  -- chip_select.chip_select
		);

	addr_adaption_0 : component q_sys_ext_epcq_flash_addr_adaption_0
		port map (
			clk                   => clk,                                     --       clock_sink.clk
			reset                 => reset_n_ports_inv,                       --            reset.reset
			avl_csr_read          => avl_csr_read,                            --          avl_csr.read
			avl_csr_waitrequest   => avl_csr_waitrequest,                     --                 .waitrequest
			avl_csr_write         => avl_csr_write,                           --                 .write
			avl_csr_addr          => avl_csr_addr,                            --                 .address
			avl_csr_wrdata        => avl_csr_wrdata,                          --                 .writedata
			avl_csr_rddata        => avl_csr_rddata,                          --                 .readdata
			avl_csr_rddata_valid  => avl_csr_rddata_valid,                    --                 .readdatavalid
			asmi_csr_addr         => addr_adaption_0_asmi_csr_address,        --         asmi_csr.address
			asmi_csr_read         => addr_adaption_0_asmi_csr_read,           --                 .read
			asmi_csr_rddata       => addr_adaption_0_asmi_csr_readdata,       --                 .readdata
			asmi_csr_write        => addr_adaption_0_asmi_csr_write,          --                 .write
			asmi_csr_wrdata       => addr_adaption_0_asmi_csr_writedata,      --                 .writedata
			asmi_csr_waitrequest  => addr_adaption_0_asmi_csr_waitrequest,    --                 .waitrequest
			asmi_csr_rddata_valid => addr_adaption_0_asmi_csr_readdatavalid,  --                 .readdatavalid
			avl_mem_write         => avl_mem_write,                           --          avl_mem.write
			avl_mem_burstcount    => avl_mem_burstcount,                      --                 .burstcount
			avl_mem_waitrequest   => avl_mem_waitrequest,                     --                 .waitrequest
			avl_mem_read          => avl_mem_read,                            --                 .read
			avl_mem_addr          => avl_mem_addr,                            --                 .address
			avl_mem_wrdata        => avl_mem_wrdata,                          --                 .writedata
			avl_mem_rddata        => avl_mem_rddata,                          --                 .readdata
			avl_mem_rddata_valid  => avl_mem_rddata_valid,                    --                 .readdatavalid
			avl_mem_byteenable    => avl_mem_byteenable,                      --                 .byteenable
			asmi_mem_addr         => addr_adaption_0_asmi_mem_address,        --         asmi_mem.address
			asmi_mem_read         => addr_adaption_0_asmi_mem_read,           --                 .read
			asmi_mem_rddata       => addr_adaption_0_asmi_mem_readdata,       --                 .readdata
			asmi_mem_write        => addr_adaption_0_asmi_mem_write,          --                 .write
			asmi_mem_wrdata       => addr_adaption_0_asmi_mem_writedata,      --                 .writedata
			asmi_mem_byteenable   => addr_adaption_0_asmi_mem_byteenable,     --                 .byteenable
			asmi_mem_burstcount   => addr_adaption_0_asmi_mem_burstcount,     --                 .burstcount
			asmi_mem_waitrequest  => addr_adaption_0_asmi_mem_waitrequest,    --                 .waitrequest
			asmi_mem_rddata_valid => addr_adaption_0_asmi_mem_readdatavalid,  --                 .readdatavalid
			irq                   => irq,                                     -- interrupt_sender.irq
			chip_select           => addr_adaption_0_chip_select_chip_select  --      chip_select.chip_select
		);

	reset_n_ports_inv <= not reset_n;

end architecture rtl; -- of q_sys_ext_epcq_flash
